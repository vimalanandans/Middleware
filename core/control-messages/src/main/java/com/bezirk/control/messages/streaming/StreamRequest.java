/**
 * @author Vijet Badigannavar (bvijet@in.bosch.com)
 */
package com.bezirk.control.messages.streaming;

import com.bezirk.control.messages.ControlMessage;
import com.bezirk.control.messages.UnicastControlMessage;
import com.bezirk.middleware.addressing.Location;
import com.bezirk.proxy.api.impl.UhuServiceEndPoint;

/**
 * This Message is internally sent by the Uhu for hand shaking with the recipient.
 */
public class StreamRequest extends UnicastControlMessage {
    /**
     * Discriminator that uniquely defines the Control message!
     */
    private final static Discriminator discriminator = ControlMessage.Discriminator.StreamRequest;
    /**
     * Location that is used for MulticastStream
     */
    public Location location = null;
    /**
     * Contains the serialized String of the Stream Descriptor pushed by the Stream
     */
    public String serialzedString = null;
    /**
     * Stream Topic of the Stream Descriptor
     */
    public String streamLabel = null;
    /**
     * Name of the file that needs to be pushed on the recipient
     */
    public String fileName = null;
    /**
     * Flag indicating secure communication. If true file transfer will be encrypted.
     */
    public boolean isSecure = false;
    /**
     * Flag indicating the communication is quantized.If true data  will be quantized and sent
     */
    public boolean isIncremental = false;
    /**
     * Flag indicating reliable transfer. If true, the communication is reliable.
     */
    public boolean allowDrops = false;
    /**
     * StreamId generated by the Proxy on corresponding Services
     */
    public short localStreamId = (short) -1;

    public StreamRequest(UhuServiceEndPoint sender, UhuServiceEndPoint recipient, String sphereName,
                         String key, Location location, String serialzedString, String streamLabel, String fileName, boolean isSecure,
                         boolean isIncremental, boolean allowDrops, short localStreamId) {
        super(sender, recipient, sphereName, discriminator, false, key);
        this.location = location;
        this.serialzedString = serialzedString;
        this.streamLabel = streamLabel;
        this.fileName = fileName;
        this.isSecure = isSecure;
        this.isIncremental = isIncremental;
        this.allowDrops = allowDrops;
        this.localStreamId = localStreamId;
    }
}
